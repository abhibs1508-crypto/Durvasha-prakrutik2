import { __toESM } from "./chunk-DbKvDyjX.js";
import { require_react } from "./react-Dzmm40ca.js";
import { require_jsx_runtime } from "./jsx-runtime-B0kp3bGK.js";

//#region node_modules/react-parallax-tilt/dist/modern/index.js
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime(), 1);
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var i = (t$1, e$1, i$1, n$1) => {
	t$1.style.transition = `${e$1} ${i$1}ms ${n$1}`;
}, n = (t$1, e$1, i$1) => Math.min(Math.max(t$1, e$1), i$1);
var s = class {
	constructor(t$1, e$1) {
		this.glareAngle = 0, this.glareOpacity = 0, this.calculateGlareSize = (t$2) => {
			const { width: e$2, height: i$2 } = t$2, n$1 = Math.sqrt(e$2 ** 2 + i$2 ** 2);
			return {
				width: n$1,
				height: n$1
			};
		}, this.setSize = (t$2) => {
			const e$2 = this.calculateGlareSize(t$2);
			this.glareEl.style.width = `${e$2.width}px`, this.glareEl.style.height = `${e$2.height}px`;
		}, this.update = (t$2, e$2, i$2, n$1) => {
			this.updateAngle(t$2, e$2.glareReverse), this.updateOpacity(t$2, e$2, i$2, n$1);
		}, this.updateAngle = (t$2, e$2) => {
			const { xPercentage: i$2, yPercentage: n$1 } = t$2, s$2 = 180 / Math.PI;
			this.glareAngle = (i$2 ? Math.atan2(n$1, -i$2) * s$2 : 0) - (e$2 ? 180 : 0);
		}, this.updateOpacity = (t$2, e$2, i$2, s$2) => {
			const { xPercentage: r$2, yPercentage: l$1 } = t$2, { glarePosition: a$1, glareReverse: o, glareMaxOpacity: h } = e$2, p = i$2 ? -1 : 1, c = s$2 ? -1 : 1, g = o ? -1 : 1;
			let d = 0;
			switch (a$1) {
				case "top":
					d = -r$2 * p * g;
					break;
				case "right":
					d = l$1 * c * g;
					break;
				case "bottom":
				case void 0:
					d = r$2 * p * g;
					break;
				case "left":
					d = -l$1 * c * g;
					break;
				case "all": d = Math.hypot(r$2, l$1);
			}
			this.glareOpacity = n(d, 0, 100) * h / 100;
		}, this.render = (t$2) => {
			const { glareColor: e$2 } = t$2;
			this.glareEl.style.transform = `rotate(${this.glareAngle}deg) translate(-50%, -50%)`, this.glareEl.style.opacity = this.glareOpacity.toString(), this.glareEl.style.background = `linear-gradient(0deg, rgba(255,255,255,0) 0%, ${e$2} 100%)`;
		}, this.glareWrapperEl = document.createElement("div"), this.glareEl = document.createElement("div"), this.glareWrapperEl.appendChild(this.glareEl), this.glareWrapperEl.className = "glare-wrapper", this.glareEl.className = "glare";
		const i$1 = {
			position: "absolute",
			top: "0",
			left: "0",
			width: "100%",
			height: "100%",
			overflow: "hidden",
			borderRadius: e$1,
			WebkitMaskImage: "-webkit-radial-gradient(white, black)",
			pointerEvents: "none"
		}, s$1 = this.calculateGlareSize(t$1), r$1 = {
			position: "absolute",
			top: "50%",
			left: "50%",
			transformOrigin: "0% 0%",
			pointerEvents: "none",
			width: `${s$1.width}px`,
			height: `${s$1.height}px`
		};
		Object.assign(this.glareWrapperEl.style, i$1), Object.assign(this.glareEl.style, r$1);
	}
};
var r = class {
	constructor() {
		this.tiltAngleX = 0, this.tiltAngleY = 0, this.tiltAngleXPercentage = 0, this.tiltAngleYPercentage = 0, this.update = (t$1, e$1) => {
			this.updateTilt(t$1, e$1), this.updateTiltManualInput(t$1, e$1), this.updateTiltReverse(e$1), this.updateTiltLimits(e$1);
		}, this.updateTilt = (t$1, e$1) => {
			const { xPercentage: i$1, yPercentage: n$1 } = t$1, { tiltMaxAngleX: s$1, tiltMaxAngleY: r$1 } = e$1;
			this.tiltAngleX = i$1 * s$1 / 100, this.tiltAngleY = n$1 * r$1 / 100 * -1;
		}, this.updateTiltManualInput = (t$1, e$1) => {
			const { tiltAngleXManual: i$1, tiltAngleYManual: n$1, tiltMaxAngleX: s$1, tiltMaxAngleY: r$1 } = e$1;
			(null !== i$1 || null !== n$1) && (this.tiltAngleX = null !== i$1 ? i$1 : 0, this.tiltAngleY = null !== n$1 ? n$1 : 0, t$1.xPercentage = 100 * this.tiltAngleX / s$1, t$1.yPercentage = 100 * this.tiltAngleY / r$1);
		}, this.updateTiltReverse = (t$1) => {
			const e$1 = t$1.tiltReverse ? -1 : 1;
			this.tiltAngleX = e$1 * this.tiltAngleX, this.tiltAngleY = e$1 * this.tiltAngleY;
		}, this.updateTiltLimits = (t$1) => {
			const { tiltAxis: e$1 } = t$1;
			this.tiltAngleX = n(this.tiltAngleX, -90, 90), this.tiltAngleY = n(this.tiltAngleY, -90, 90);
			e$1 && (this.tiltAngleX = "x" === e$1 ? this.tiltAngleX : 0, this.tiltAngleY = "y" === e$1 ? this.tiltAngleY : 0);
		}, this.updateTiltAnglesPercentage = (t$1) => {
			const { tiltMaxAngleX: e$1, tiltMaxAngleY: i$1 } = t$1;
			this.tiltAngleXPercentage = this.tiltAngleX / e$1 * 100, this.tiltAngleYPercentage = this.tiltAngleY / i$1 * 100;
		}, this.render = (t$1) => {
			t$1.style.transform += `rotateX(${this.tiltAngleX}deg) rotateY(${this.tiltAngleY}deg) `;
		};
	}
};
var l = {
	scale: 1,
	perspective: 1e3,
	flipVertically: !1,
	flipHorizontally: !1,
	reset: !0,
	transitionEasing: "cubic-bezier(.03,.98,.52,.99)",
	transitionSpeed: 400,
	trackOnWindow: !1,
	gyroscope: !1,
	tiltEnable: !0,
	tiltReverse: !1,
	tiltAngleXInitial: 0,
	tiltAngleYInitial: 0,
	tiltMaxAngleX: 20,
	tiltMaxAngleY: 20,
	tiltAxis: void 0,
	tiltAngleXManual: null,
	tiltAngleYManual: null,
	glareEnable: !1,
	glareMaxOpacity: .7,
	glareColor: "#ffffff",
	glarePosition: "bottom",
	glareReverse: !1,
	glareBorderRadius: "0"
};
var a = class extends import_react.PureComponent {
	constructor() {
		super(...arguments), this.wrapperEl = {
			node: null,
			size: {
				width: 0,
				height: 0,
				left: 0,
				top: 0
			},
			clientPosition: {
				x: null,
				y: null,
				xPercentage: 0,
				yPercentage: 0
			},
			updateAnimationId: null,
			scale: 1
		}, this.tilt = null, this.glare = null, this.addDeviceOrientationEventListener = async () => {
			if (!window.DeviceOrientationEvent) return;
			const t$1 = DeviceOrientationEvent.requestPermission;
			if ("function" == typeof t$1) "granted" === await t$1() && window.addEventListener("deviceorientation", this.onMove);
			else window.addEventListener("deviceorientation", this.onMove);
		}, this.setSize = () => {
			this.setWrapperElSize(), this.glare && this.glare.setSize(this.wrapperEl.size);
		}, this.mainLoop = (t$1) => {
			null !== this.wrapperEl.updateAnimationId && cancelAnimationFrame(this.wrapperEl.updateAnimationId), this.processInput(t$1), this.update(t$1.type), this.wrapperEl.updateAnimationId = requestAnimationFrame(this.renderFrame);
		}, this.onEnter = (t$1) => {
			const { onEnter: e$1 } = this.props;
			this.setSize(), this.wrapperEl.node.style.willChange = "transform", this.setTransitions(), e$1 && e$1({ event: t$1 });
		}, this.onMove = (t$1) => {
			this.mainLoop(t$1), this.emitOnMove(t$1);
		}, this.onLeave = (t$1) => {
			const { onLeave: e$1 } = this.props;
			if (this.setTransitions(), e$1 && e$1({ event: t$1 }), this.props.reset) {
				const t$2 = new CustomEvent("autoreset");
				this.onMove(t$2);
			}
		}, this.processInput = (t$1) => {
			const { scale: e$1 } = this.props;
			switch (t$1.type) {
				case "mousemove":
					this.wrapperEl.clientPosition.x = t$1.pageX, this.wrapperEl.clientPosition.y = t$1.pageY, this.wrapperEl.scale = e$1;
					break;
				case "touchmove":
					this.wrapperEl.clientPosition.x = t$1.touches[0].pageX, this.wrapperEl.clientPosition.y = t$1.touches[0].pageY, this.wrapperEl.scale = e$1;
					break;
				case "deviceorientation":
					this.processInputDeviceOrientation(t$1), this.wrapperEl.scale = e$1;
					break;
				case "autoreset": {
					const { tiltAngleXInitial: t$2, tiltAngleYInitial: e$2, tiltMaxAngleX: i$1, tiltMaxAngleY: s$1 } = this.props, r$1 = e$2 / s$1 * 100;
					this.wrapperEl.clientPosition.xPercentage = n(t$2 / i$1 * 100, -100, 100), this.wrapperEl.clientPosition.yPercentage = n(r$1, -100, 100), this.wrapperEl.scale = 1;
					break;
				}
			}
		}, this.processInputDeviceOrientation = (t$1) => {
			if (!t$1.gamma || !t$1.beta || !this.props.gyroscope) return;
			const { tiltMaxAngleX: e$1, tiltMaxAngleY: i$1 } = this.props, s$1 = t$1.gamma;
			this.wrapperEl.clientPosition.xPercentage = t$1.beta / e$1 * 100, this.wrapperEl.clientPosition.yPercentage = s$1 / i$1 * 100, this.wrapperEl.clientPosition.xPercentage = n(this.wrapperEl.clientPosition.xPercentage, -100, 100), this.wrapperEl.clientPosition.yPercentage = n(this.wrapperEl.clientPosition.yPercentage, -100, 100);
		}, this.update = (t$1) => {
			const { tiltEnable: e$1, flipVertically: i$1, flipHorizontally: n$1 } = this.props;
			"autoreset" !== t$1 && "deviceorientation" !== t$1 && "propChange" !== t$1 && this.updateClientInput(), e$1 && this.tilt.update(this.wrapperEl.clientPosition, this.props), this.updateFlip(), this.tilt.updateTiltAnglesPercentage(this.props), this.glare && this.glare.update(this.wrapperEl.clientPosition, this.props, i$1, n$1);
		}, this.updateClientInput = () => {
			const { trackOnWindow: t$1 } = this.props;
			let e$1, i$1;
			if (t$1) {
				const { x: t$2, y: n$1 } = this.wrapperEl.clientPosition;
				e$1 = n$1 / window.innerHeight * 200 - 100, i$1 = t$2 / window.innerWidth * 200 - 100;
			} else {
				const { size: { width: t$2, height: n$1, left: s$1, top: r$1 }, clientPosition: { x: l$1, y: a$1 } } = this.wrapperEl;
				e$1 = (a$1 - r$1) / n$1 * 200 - 100, i$1 = (l$1 - s$1) / t$2 * 200 - 100;
			}
			this.wrapperEl.clientPosition.xPercentage = n(e$1, -100, 100), this.wrapperEl.clientPosition.yPercentage = n(i$1, -100, 100);
		}, this.updateFlip = () => {
			const { flipVertically: t$1, flipHorizontally: e$1 } = this.props;
			t$1 && (this.tilt.tiltAngleX += 180, this.tilt.tiltAngleY *= -1), e$1 && (this.tilt.tiltAngleY += 180);
		}, this.renderFrame = () => {
			this.resetWrapperElTransform(), this.renderPerspective(), this.tilt.render(this.wrapperEl.node), this.renderScale(), this.glare && this.glare.render(this.props);
		};
	}
	componentDidMount() {
		if (this.tilt = new r(), this.initGlare(), this.setSize(), this.addEventListeners(), "undefined" == typeof CustomEvent) return;
		const t$1 = new CustomEvent("autoreset");
		this.mainLoop(t$1);
		const e$1 = new CustomEvent("initial");
		this.emitOnMove(e$1);
	}
	componentWillUnmount() {
		null !== this.wrapperEl.updateAnimationId && cancelAnimationFrame(this.wrapperEl.updateAnimationId), this.removeEventListeners();
	}
	componentDidUpdate() {
		const t$1 = new CustomEvent("propChange");
		this.mainLoop(t$1), this.emitOnMove(t$1);
	}
	addEventListeners() {
		const { trackOnWindow: t$1, gyroscope: e$1 } = this.props;
		window.addEventListener("resize", this.setSize), t$1 && (window.addEventListener("mouseenter", this.onEnter), window.addEventListener("mousemove", this.onMove), window.addEventListener("mouseout", this.onLeave), window.addEventListener("touchstart", this.onEnter), window.addEventListener("touchmove", this.onMove), window.addEventListener("touchend", this.onLeave)), e$1 && this.addDeviceOrientationEventListener();
	}
	removeEventListeners() {
		const { trackOnWindow: t$1, gyroscope: e$1 } = this.props;
		window.removeEventListener("resize", this.setSize), t$1 && (window.removeEventListener("mouseenter", this.onEnter), window.removeEventListener("mousemove", this.onMove), window.removeEventListener("mouseout", this.onLeave), window.removeEventListener("touchstart", this.onEnter), window.removeEventListener("touchmove", this.onMove), window.removeEventListener("touchend", this.onLeave)), e$1 && window.DeviceOrientationEvent && window.removeEventListener("deviceorientation", this.onMove);
	}
	setWrapperElSize() {
		const t$1 = this.wrapperEl.node.getBoundingClientRect();
		this.wrapperEl.size.width = this.wrapperEl.node.offsetWidth, this.wrapperEl.size.height = this.wrapperEl.node.offsetHeight, this.wrapperEl.size.left = t$1.left + window.scrollX, this.wrapperEl.size.top = t$1.top + window.scrollY;
	}
	initGlare() {
		const { glareEnable: t$1, glareBorderRadius: e$1 } = this.props;
		t$1 && (this.glare = new s(this.wrapperEl.size, e$1), this.wrapperEl.node.appendChild(this.glare.glareWrapperEl));
	}
	emitOnMove(t$1) {
		const { onMove: e$1 } = this.props;
		if (!e$1) return;
		let i$1 = 0, n$1 = 0;
		this.glare && (i$1 = this.glare.glareAngle, n$1 = this.glare.glareOpacity), e$1({
			tiltAngleX: this.tilt.tiltAngleX,
			tiltAngleY: this.tilt.tiltAngleY,
			tiltAngleXPercentage: this.tilt.tiltAngleXPercentage,
			tiltAngleYPercentage: this.tilt.tiltAngleYPercentage,
			glareAngle: i$1,
			glareOpacity: n$1,
			event: t$1
		});
	}
	resetWrapperElTransform() {
		this.wrapperEl.node.style.transform = "";
	}
	renderPerspective() {
		const { perspective: t$1 } = this.props;
		this.wrapperEl.node.style.transform += `perspective(${t$1}px) `;
	}
	renderScale() {
		const { scale: t$1 } = this.wrapperEl;
		this.wrapperEl.node.style.transform += `scale3d(${t$1},${t$1},${t$1})`;
	}
	setTransitions() {
		const { transitionSpeed: t$1, transitionEasing: e$1 } = this.props;
		i(this.wrapperEl.node, "all", t$1, e$1), this.glare && i(this.glare.glareEl, "opacity", t$1, e$1);
	}
	render() {
		const { children: e$1, className: i$1, style: n$1 } = this.props;
		return (0, import_jsx_runtime.jsx)("div", {
			ref: (t$1) => {
				this.wrapperEl.node = t$1;
			},
			onMouseEnter: this.onEnter,
			onMouseMove: this.onMove,
			onMouseLeave: this.onLeave,
			onTouchStart: this.onEnter,
			onTouchMove: this.onMove,
			onTouchEnd: this.onLeave,
			className: i$1,
			style: n$1,
			children: e$1
		});
	}
};
a.defaultProps = l;

//#endregion
export { a as default };
//# sourceMappingURL=react-parallax-tilt.js.map